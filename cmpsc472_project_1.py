# -*- coding: utf-8 -*-
"""CMPSC472 Project 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18vNwJyXsM2MMvNwi4c4bhQcnAqgiJKE9
"""



# Commented out IPython magic to ensure Python compatibility.
# %%writefile word_count.c
# #include <stdio.h>
# #include <stdlib.h>
# #include <string.h>
# #include <pthread.h>
# #include <unistd.h>
# #include <sys/wait.h>
# #include <time.h>
# 
# #define BUFFER_SIZE 1024
# #define THREAD_COUNT 1
# 
# const char *files[] = {"/bib", "/paper1", "/paper2", "/progc", "/progl", "/progp", "/trans"};
# const char *word = "the";
# 
# // Structure to pass arguments to the thread function
# typedef struct {
#     const char *path;
#     const char *word;
#     int start;
#     int end;
#     int count;
# } ThreadArgs;
# 
# int countOccurrences(const char *path, const char *word, int start, int end) {
#     FILE *fptr = fopen(path, "r");
#     if (fptr == NULL) {
#         printf("Unable to open file %s.\n", path);
#         return 0;
#     }
# 
#     char str[BUFFER_SIZE];
#     char *pos;
#     int index, count = 0;
# 
#     fseek(fptr, start, SEEK_SET);
# 
#     // Check for partial lines at the beginning of the chunk
#     if (start > 0) {
#         // Read until a newline character or end of file
#         fgets(str, BUFFER_SIZE, fptr);
#     }
# 
# 
#     while (ftell(fptr) < end && fgets(str, BUFFER_SIZE, fptr) != NULL) {
#         index = 0;
#         while ((pos = strstr(str + index, word)) != NULL) {
#             index = (pos - str) + 1;
#             count++;
#         }
#     }
#     fclose(fptr);
#     return count;
# }
# 
# // Thread function to count occurrences in a chunk of the file
# void *threadFunc(void *arg) {
#     ThreadArgs *args = (ThreadArgs *)arg;
#     args->count = countOccurrences(args->path, args->word, args->start, args->end);
#     return NULL;
# }
# 
# // Function to process a file and count occurrences of a word
# void processFile(const char *path, const char *word, int write_fd) {
#     FILE *fptr = fopen(path, "r");
#     if (fptr == NULL) {
#         printf("Unable to open file %s.\n", path);
#         exit(EXIT_FAILURE);
#     }
# 
#     // Get file size
#     fseek(fptr, 0, SEEK_END);
#     int fileSize = ftell(fptr);
#     fseek(fptr, 0, SEEK_SET);
# 
#     pthread_t threads[THREAD_COUNT];
#     ThreadArgs threadArgs[THREAD_COUNT];
#     int chunkSize = fileSize / THREAD_COUNT;
#     int totalWordCount = 0;
# 
#     // Create threads for each chunk
#     for (int i = 0; i < THREAD_COUNT; i++) {
#         threadArgs[i].path = path;
#         threadArgs[i].word = word;
#         threadArgs[i].start = i * chunkSize;
#         threadArgs[i].end = (i == THREAD_COUNT - 1) ? fileSize : (i + 1) * chunkSize;
#         threadArgs[i].count = 0;
# 
#         pthread_create(&threads[i], NULL, threadFunc, &threadArgs[i]);
#     }
# 
#     // Wait for threads to finish and get the word count
#     for (int i = 0; i < THREAD_COUNT; i++) {
#         pthread_join(threads[i], NULL);
#         totalWordCount += threadArgs[i].count;
#     }
# 
#     write(write_fd, &totalWordCount, sizeof(totalWordCount));
# 
#     fclose(fptr);
# }
# 
# int main() {
#     int numFiles = sizeof(files) / sizeof(files[0]);
# 
#     clock_t start_time = clock();
# 
#     for(int i = 0; i < numFiles; i++){
#         // Initialize pipe
#         int pipefd[2];
#         if (pipe(pipefd) == -1) {
#             perror("pipe failed");
#             exit(EXIT_FAILURE);
#         }
# 
#         pid_t pid = fork();
#         if (pid == 0) {
#             close(pipefd[0]);
# 
#             // Child process: process the file
#             processFile(files[i], word, pipefd[1]);
# 
#             close(pipefd[1]);
#             exit(EXIT_SUCCESS);  // Exit child process
#         } else if (pid < 0) {
#             perror("fork failed");
#             exit(EXIT_FAILURE);
#         }
# 
#         close(pipefd[1]);
#         int wordCount = 0;
#         read(pipefd[0], &wordCount, sizeof(wordCount));
#         close(pipefd[0]);
#         printf("'%s' is found %d times in file %s.\n", word, wordCount, files[i]);
#     }
# 
#     for (int i = 0; i < numFiles; i++) {
#         wait(NULL);
#     }
# 
#     clock_t end_time = clock();
#     double elapsed_time = (double)(end_time - start_time) / CLOCKS_PER_SEC;
#     printf("All files processed in %fs.\n", elapsed_time);
# 
#     return 0;
# }

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# gcc word_count.c -o word_count
# ./word_count

